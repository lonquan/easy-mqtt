<!--
Sync Impact Report:
- Version change: 1.0.0 → 1.1.0
- Modified principles: None
- Added sections: 类成员声明顺序 (Class Member Declaration Order)
- Removed sections: None
- Templates requiring updates: 
  ✅ constitution.md (updated)
  ✅ plan-template.md (reviewed - no updates needed)
  ✅ spec-template.md (reviewed - no updates needed) 
  ✅ tasks-template.md (reviewed - no updates needed)
- Follow-up TODOs: None
-->

# EasyMqttFactory 项目章程

**版本**: 1.1.0
**批准日期**: 2025-10-18  
**最后修订**: 2025-10-20

## 项目身份

**项目名称**: EasyMqttFactory  
**项目类型**: PHP Composer Package  
**包名**: lonquan/laravel-mqtt-factory
**命名空间**: MqttFactory  
**PHP 版本要求**: >= 8.4  
**主要目标**: 为 php-mqtt/client 提供易用的 Factory 封装，简化 MQTT 连接管理、消息发布/订阅和 JWT 认证
**开发状态**: 开发阶段（0.x 版本）

## 核心原则

### 原则一：简单性与实用主义
**声明**: 所有代码设计必须优先考虑简单性和可读性，同时保持实用主义导向，避免过度设计和不必要的抽象。

**规则**:
- 每个类和函数保持单一职责
- 避免过早抽象，只在明确需要时才进行抽象
- 代码组织按功能模块划分，而非复杂的分层架构
- 优先使用组合而非继承
- 选择直观明了的解决方案，而非巧妙但难以理解的技巧
- 如果代码需要大量注释才能理解，说明设计过于复杂
- 新增功能应该通过扩展现有接口实现，而非修改现有代码
- 使用设计模式时必须有明确的理由，不为使用模式而使用模式
- 代码应该自解释，变量和方法命名应清晰表达意图

**理由**: SDK 的主要使用者是其他开发者，简单清晰的代码能够降低接入成本、提高可维护性和可移植性。过度的架构设计反而会增加理解和使用的难度。实用主义确保我们专注于解决实际问题而非追求理论完美。

### 原则二：Fluent API 设计哲学
**声明**: 提供直观、流畅的 API 设计，使开发者能够以自然的方式表达 MQTT 操作意图。

**规则**:
- 提供多种使用方式，从简单到复杂满足不同场景需求
- 支持静态工厂方法快速完成常见操作（如 `Factory::publish()`）
- 支持链式调用构建复杂操作（如 `Factory::withConnection()->publish()->publish()`）
- 支持对象化构建消息（如 `Message::make()->toTopic()->send()`）
- 方法命名遵循自然语言习惯，如 `publishTo()`, `withConnection()`, `toTopic()`
- 所有公开 API 必须提供完整的类型提示和返回值声明
- 参数设计遵循"常用参数在前，可选参数在后"的原则
- 为常见用例提供便捷方法，避免强制使用冗长的配置
- API 设计必须支持 IDE 自动完成和类型检查

**理由**: MQTT 操作通常涉及连接管理、主题订阅、消息发布等多个步骤。Fluent API 设计能够让代码更接近自然语言，降低认知负担，提高代码可读性和开发效率。多种使用方式的支持让简单场景简单做，复杂场景也能优雅处理。

### 原则三：框架无关性
**声明**: 核心功能必须独立于任何 PHP 框架，同时为流行框架提供便捷的集成方式。

**规则**:
- 核心代码不得直接依赖 Laravel、Symfony 等框架特定功能
- 使用 PSR 标准接口代替框架特定实现（如 PSR-3 日志接口）
- 框架集成功能应通过独立的适配器或服务提供者实现
- 配置管理应支持数组、文件、环境变量等多种方式
- 依赖注入使用构造函数注入，避免使用服务定位器模式
- 可选的框架集成功能应作为单独的包或可选依赖
- 示例代码应同时提供原生 PHP 和框架集成两种方式

**理由**: 框架无关性确保包的可移植性和长期可维护性。开发者可以在任何 PHP 项目中使用此包，不受框架选择的限制。同时，为流行框架提供便捷集成能够提升在特定生态中的用户体验。

### 原则四：可靠性优先
**声明**: MQTT 连接和消息传递的可靠性是首要关注点，必须提供完善的错误处理和恢复机制。

**规则**:
- 实现指数退避的自动重连机制（1s, 2s, 4s）
- 区分可恢复错误（网络故障）和不可恢复错误（认证失败）
- 使用单例模式管理连接，避免重复建连
- 在长期运行环境（如 Octane）中提供连接健康检查和自动清理
- 所有异常必须携带足够的上下文信息用于调试
- 提供详细的日志记录，包括连接状态、消息发布/订阅、错误信息
- 关键操作必须有明确的成功/失败反馈
- 订阅处理器的异常不应中断订阅循环
- 连接断开后自动清理资源

**理由**: MQTT 通常用于物联网和实时通信场景，连接的稳定性和消息传递的可靠性直接影响业务。完善的错误处理和恢复机制能够减少人工干预，提高系统整体可用性。详细的日志和上下文信息能够快速定位和解决问题。

### 原则五：开发阶段灵活性
**声明**: 在项目正式发布（release）前，接口调整优先考虑最佳设计，不需要严格保持向后兼容。

**规则**:
- **开发阶段**（0.x.y 版本）：
  - 允许进行破坏性 API 变更以实现更好的设计
  - 接口调整应在充分评估后进行，避免频繁反复
  - 每次重大调整必须在 CHANGELOG 中明确标注 "BREAKING CHANGE"
  - 版本号遵循语义化版本，主版本保持 0 表示开发阶段
  - 次版本号（0.x.0）表示可能包含破坏性变更的功能添加
  - 修订号（0.x.y）表示 bug 修复和小的改进
  
- **正式发布后**（1.x.y+ 版本）：
  - 必须严格遵循语义化版本约定
  - 破坏性变更只能在主版本升级时引入（x.0.0）
  - 次版本更新必须向后兼容（x.y.0）
  - 修订版本仅包含 bug 修复（x.y.z）
  - 提供详细的迁移指南和废弃通知
  - 废弃功能至少保留一个主版本周期

**理由**: 在开发阶段保持灵活性，能够快速迭代并找到最优设计，避免因过早的兼容性承诺而背负技术债。正式发布后严格的版本管理策略则确保使用者的稳定性和可预期性，减少升级风险。

## 架构治理

### 代码组织规范
- **模块化**: 按业务功能组织代码，每个模块职责清晰
- **扁平化结构**: 避免过深的目录层级，保持结构简单明了
- **接口隔离**: 通过接口定义模块间的交互契约
- **纯 PHP**: 核心功能不依赖特定框架，保证包的可移植性
- **依赖注入**: 使用构造函数注入，避免使用服务定位器模式
- **单一职责**: 每个类只负责一个明确的功能领域

### 目录结构规范

```
src/
├── Contracts/          # 接口定义（如 MessageHandler）
├── Exceptions/         # 自定义异常类
├── Support/            # 工具类（如生成器、序列化器）
├── Factory.php         # 主要入口类（静态 Facade）
├── ConnectionManager.php  # 连接管理（单例模式）
├── ConnectionContext.php  # 连接上下文（Fluent API）
├── Message.php         # 消息封装
└── JwtToken.php        # JWT Token 值对象

tests/
├── Unit/              # 单元测试
├── Integration/       # 集成测试
└── Feature/           # 功能测试

docs/                  # 详细文档
README.md             # 项目介绍和快速开始
CHANGELOG.md          # 版本变更记录
```

### 技术栈约束
- **核心语言**: PHP 8.4+
- **MQTT 客户端**: php-mqtt/client ^2.0
- **JWT 处理**: firebase/php-jwt ^6.0
- **编码标准**: PSR-12 编码规范
- **日志标准**: PSR-3 日志接口
- **依赖管理**: Composer
- **测试框架**: PHPUnit 11+
- **静态分析**: PHPStan / Psalm (Level 8+)
- **代码格式化**: Laravel Pint（遵循 Laravel 风格）

### 设计模式使用
- **Factory Pattern**: 提供统一的创建接口（Factory 类）
- **Singleton Pattern**: 管理 MQTT 连接实例，避免重复连接（ConnectionManager）
- **Fluent Interface**: 提供链式调用的 API（ConnectionContext, Message）
- **Value Object**: 不可变的值对象（Message, JwtToken）
- **Strategy Pattern**: 可扩展的消息处理器（MessageHandler 接口）

### 扩展性要求
- 提供 Laravel 服务提供者，支持配置文件发布和门面（Facade）
- 支持通过接口扩展消息处理逻辑
- 支持自定义 Client ID 生成策略
- 预留配置扩展点，支持未来添加新的连接参数

## 开发标准

### 开发哲学

#### 核心理念
- **渐进式进步胜过大爆炸式改动** - 小的变更能够编译并通过测试
- **从现有代码中学习** - 在实施前先研究和规划
- **实用主义胜过教条主义** - 适应项目实际情况
- **清晰意图胜过巧妙代码** - 选择简单明显的解决方案
- **接口优先** - 先定义契约，再实现细节
- **快速迭代优于过度设计** - 开发阶段优先追求最佳设计

#### 简单性原则
- 每个函数/类单一职责
- 避免过早抽象
- 不使用巧妙技巧 - 选择简单的解决方案
- 如果需要解释，说明过于复杂
- 优先使用组合而非继承

### 开发流程

#### 1. 规划与分阶段
将复杂工作分解为 3-5 个阶段，在 `specs/[###-feature]/plan.md` 中记录：

```markdown
## Stage N: [Name]
**Goal**: [Specific deliverable]
**Success Criteria**: [Testable outcomes]
**Tests**: [Specific test cases]
**Status**: [Not Started|In Progress|Complete]
```

- 随进度更新状态
- 所有阶段完成后删除 plan.md 文件

#### 2. 实施流程
1. **理解** - 研究代码库中的现有模式
2. **测试** - 先编写测试（红）
3. **实现** - 编写最少代码通过测试（绿）
4. **重构** - 在测试通过的情况下清理代码
5. **提交** - 使用清晰的提交信息关联计划

#### 3. 遇到困难时（3 次尝试后）
**关键规则**: 每个问题最多尝试 3 次，然后停止。

1. **记录失败内容**：
   - 尝试了什么
   - 具体错误信息
   - 认为失败的原因

2. **研究替代方案**：
   - 找到 2-3 个类似实现
   - 记录使用的不同方法

3. **质疑基本假设**：
   - 这是正确的抽象层级吗？
   - 能否拆分为更小的问题？
   - 是否有更简单的方法？

4. **尝试不同角度**：
   - 不同的设计模式？
   - 不同的架构方式？
   - 移除抽象而不是添加？

### 技术标准

#### 架构原则
- **组合优于继承** - 使用依赖注入和接口
- **接口优于实现** - 启用测试和灵活性
- **显式优于隐式** - 清晰的数据流和依赖关系
- **不可变优于可变** - 优先使用不可变对象（尤其是值对象）
- **尽可能测试驱动** - 永不禁用测试，而是修复它们

### 编码规范
- 遵循 PSR-12 编码标准
- 使用 Laravel Pint 进行代码格式化（风格遵循 Laravel）
- 所有公开类和方法必须有完整的 PHPDoc 注释
- 使用严格类型声明 `declare(strict_types=1)`
- 所有公开方法必须有完整的类型提示和返回值声明
- 变量和方法命名采用语义化的英文命名，体现业务含义
- 使用命名参数提高代码可读性（PHP >= 8.4）
- 避免使用魔术方法，除非能显著提升 API 易用性（如 Message 的 ArrayAccess）

#### 类成员声明顺序
**声明**: 所有类成员的声明必须遵循统一的顺序，以提高代码可读性和一致性。

**规则**:
1. **常量**（const）- 类级别的常量定义
2. **静态属性**（按可见性排序：public static → protected static → private static）
3. **实例属性**（按可见性排序：public → protected → private）
4. **构造函数**（__construct）
5. **静态方法**（按可见性排序：public → protected → private）
6. **实例方法**（按可见性排序：public → protected → private）
7. **魔术方法**（如 __toString, __invoke, __get, __set 等）

**理由**: 统一的成员声明顺序能够提高代码的可读性和可维护性。开发者能够快速定位特定类型的成员，减少认知负担。这种顺序遵循了从静态到实例、从属性到方法的逻辑分组，符合大多数开发者的阅读习惯。

#### 代码质量
**每次提交必须**：
- 成功通过静态分析（PHPStan/Psalm level 8+）
- 通过所有现有测试
- 包含新功能的测试
- 遵循项目格式化/检查规范
- 测试覆盖率不得降低

**提交前**：
- 运行格式化工具（Laravel Pint）
- 运行静态分析工具（PHPStan）
- 自我审查变更
- 确保提交信息解释"为什么"

#### 错误处理
- 快速失败并提供描述性异常消息
- 使用领域特定的异常类型（继承自 MqttException）
- 异常必须携带上下文信息，使用 `withContext()` 方法
- 在适当层级处理错误（网络层、业务层分离）
- 永不静默吞噬异常
- 异常消息必须对使用者友好且具有可操作性
- 区分可恢复错误和不可恢复错误

### 决策框架
当存在多个有效方法时，基于以下标准选择：

1. **可测试性** - 我能轻松测试这个吗？
2. **可读性** - 6个月后有人能理解这个吗？
3. **一致性** - 这符合项目模式吗？
4. **简单性** - 这是有效的最简单解决方案吗？
5. **可移植性** - 这是否依赖特定框架或环境？
6. **可靠性** - 这在异常情况下是否足够健壮？

### 项目集成

#### 学习代码库
- 找到 3 个类似的功能/组件
- 识别通用模式和约定
- 尽可能使用相同的设计模式
- 遵循现有测试模式

#### 依赖管理
- 最小化外部依赖
- 优先使用 PSR 标准接口
- 所有依赖必须有明确的理由
- 不要在没有强有力理由的情况下引入新依赖
- 定期检查依赖安全漏洞

### 测试要求
- 核心业务逻辑测试覆盖率不低于 90%
- 所有公开 API 必须有对应的功能测试
- 连接管理、消息发布/订阅必须有完整的集成测试（使用 Mock）
- 使用 TDD 方式开发新功能
- 边界条件和异常场景必须有测试覆盖
- 重连逻辑、健康检查等可靠性功能必须有专门测试

#### 测试指南
- 测试行为，不是实现
- 尽可能每个测试一个断言
- 清晰的测试名称描述场景
- 使用现有测试工具/助手
- 测试应该是确定性的
- 测试必须独立运行，不依赖执行顺序
- Mock 外部依赖（MQTT Broker）

### 版本控制
- 采用语义化版本（Semantic Versioning）
  - **开发阶段**（0.x.y）：次版本号表示功能添加（可能破坏性），修订号表示bug修复
  - **正式发布后**（1.x.y+）：严格遵循语义化版本，主版本号用于破坏性变更
- 遵循 Conventional Commits 规范
  - `feat:` 新功能
  - `fix:` bug 修复
  - `docs:` 文档更新
  - `refactor:` 重构
  - `test:` 测试相关
  - `chore:` 构建/工具相关
- 每个功能开发使用独立的 feature 分支
- 代码提交必须通过 CI/CD 检查
- 发布版本必须有完整的 CHANGELOG
- 主分支必须始终保持可发布状态

### 质量门控

#### 完成定义
- [ ] 测试已编写并通过
- [ ] 代码遵循项目约定
- [ ] 无静态分析警告（PHPStan/Psalm level 8+）
- [ ] 无格式化警告（Laravel Pint）
- [ ] 提交信息清晰
- [ ] 实现符合计划
- [ ] 公开 API 有完整的文档注释
- [ ] CHANGELOG 已更新
- [ ] README 示例已验证

### 重要提醒

**永不**：
- 使用 `--no-verify` 绕过提交钩子
- 禁用测试而不是修复它们
- 提交无法通过静态分析的代码
- 做假设 - 用现有代码验证
- 在公开 API 中使用 `@internal` 注解逃避文档
- 静默吞噬异常
- 在核心代码中使用框架特定功能

**始终**：
- 增量提交可工作的代码
- 随进度更新计划文档
- 从现有实现中学习
- 3 次失败尝试后停止并重新评估
- 使用严格类型声明
- 为异常提供上下文信息
- 记录重要的设计决策

**开发阶段特别注意**：
- API 调整前充分评估，避免频繁反复
- 每次重大变更在 CHANGELOG 中明确标注 "BREAKING CHANGE"
- 记录设计决策的演变过程
- 保持简单，避免过度设计

## 文档标准

### 必需文档
- **README.md**: 项目介绍、安装、快速开始、开发状态说明
- **CHANGELOG.md**: 版本变更记录（遵循 Keep a Changelog 格式）
- **CONTRIBUTING.md**: 贡献指南
- **LICENSE**: 开源协议（MIT）
- **docs/**: 详细使用文档和 API 参考

### 文档要求
- 所有公开类和方法必须有 PHPDoc 注释
- 复杂业务逻辑必须有内联注释说明
- 提供完整的使用示例（覆盖常见场景）
- API 变更必须在 CHANGELOG 中记录
- 开发阶段的破坏性变更必须在 CHANGELOG 中明确标注 "BREAKING CHANGE"
- 正式发布后的重大变更必须提供迁移指南
- README 必须包含快速开始、完整的使用示例、配置说明

### 代码注释原则
- 注释说明"为什么"而不是"是什么"
- 复杂算法和业务规则必须注释
- 临时解决方案必须标记 `@todo` 并说明原因
- 不要注释显而易见的代码
- 使用 PHPDoc 标准注解（@param, @return, @throws 等）
- 重要的设计决策应在类级别注释中说明

## 安全标准

### 敏感信息处理
- 所有连接密钥、JWT Secret 必须可配置，不得硬编码
- 日志记录必须脱敏（密码、密钥等敏感信息）
- 支持敏感配置通过环境变量传入
- MQTT 请求和响应必须完整记录（敏感字段脱敏）
- JWT Token 必须设置合理的过期时间

### 数据验证
- 所有外部输入必须验证（主题名称、配置参数等）
- 发布主题不能包含通配符
- 订阅主题的通配符使用必须符合 MQTT 规范
- 主题不能以 $ 开头（系统主题保留）
- 配置参数必须进行类型和格式验证

### 连接安全
- 支持用户名/密码认证
- 支持 JWT Token 认证（WebSocket）
- 连接超时和重试参数可配置
- 自动断开闲置连接，防止资源泄漏
- 提供连接健康检查机制

### 依赖安全
- 定期检查依赖安全漏洞
- 使用 Composer 审计工具（`composer audit`）
- 及时更新有安全漏洞的依赖
- 固定依赖版本范围，避免意外引入破坏性变更

## 治理

### 修订程序
本宪章的修订需要经过以下流程：
1. 提出修订提案，说明修订原因和影响范围
2. 技术团队讨论和评估
3. 相关利益方审查和批准
4. 更新版本号并记录变更历史
5. 同步更新相关模板和文档

### 版本管理
- **主版本号**: 不兼容的原则变更或删除
- **次版本号**: 新增原则或重要指导原则
- **修订版本号**: 文字修正、澄清说明等

### 合规检查
- 每个新功能开发前必须进行宪章合规检查
- 定期审查现有代码的宪章遵循情况
- 建立违规处理和改进机制
- 将宪章遵循情况纳入代码审查标准

## 附录：源代码参考

本章程基于以下源代码实现制定：
- **源项目路径**: `/Users/quan/wwwroot/orange/payment-hub/api/infrastructure/Mqtt`
- **主要文件**: Factory.php, ConnectionManager.php, Message.php, ConnectionContext.php
- **设计模式**: Factory + Singleton + Fluent Interface
- **核心特性**: 连接管理、消息发布/订阅、JWT 认证、自动重连、Octane 适配
